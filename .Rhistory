#return(names(tables))
orders <- order(names(tables))
ordered.tables <- llply(orders, function(x) { tables[[x]] })
names(ordered.tables) <- names(tables)[orders]
#Start parsing the URLs
docs <- NULL
url.vector <- NULL
for (i in urls) {
cat(i, "\n")
doc <- try_default(xmlParse(i), NULL, quiet = TRUE)
if (!is.null(doc)) {
docs <- c(docs, doc) #Keep non-empty documents
url.vector <- c(url.vector, i) #Keep urls that have data
}
}
#Turn the XML documents into a list of data frames
ctr <- 1
for (j in names(ordered.tables)) {
fields <- unlist(ordered.tables[[ctr]])
frame <- docsToDataFrame(docs = docs, node = j, fields = fields, urls = url.vector)
if (j == "atbat") {
frame <- frame$final
if (any(names(tables) == "pitch")) {
atbat.id <- frame$atbat_id
}
}
if (j == "pitch" & any(names(tables) == "atbat")) {
frame$num <- atbat.id
}
if (ctr == 1) {
frames <- frame
} else {
frames <- list(frames, frame)
}
ctr <- ctr + 1
}
if (is.list(frames)) names(frames) <- names(ordered.tables)
return(frames)
}
data <- urlsToDataFrame(urls = urls, tables = list(atbat = ab))
str(data)
View(atbats)
View(data)
urlsToDataFrame <- function(urls, tables = list(atbat = NULL, pitch = NULL)) {
if (is.null(names(tables))) stop("Please specify at least one XML node of interest.")
#Order tables alphabetically. This is important because the atbat node must be parsed first if you want an atbat ID for the pitch table
orders <- order(names(tables))
ordered.tables <- llply(orders, function(x) { tables[[x]] })
names(ordered.tables) <- names(tables)[orders]
#Start parsing the URLs
docs <- NULL
url.vector <- NULL
for (i in urls) {
cat(i, "\n")
doc <- try_default(xmlParse(i), NULL, quiet = TRUE)
if (!is.null(doc)) {
docs <- c(docs, doc) #Keep non-empty documents
url.vector <- c(url.vector, i) #Keep urls that have data
}
}
#Turn the XML documents into a list of data frames
ctr <- 1
for (j in names(ordered.tables)) {
fields <- unlist(ordered.tables[[ctr]])
frame <- docsToDataFrame(docs = docs, node = j, fields = fields, urls = url.vector)
if (j == "atbat") {
frame <- frame$final
if (any(names(tables) == "pitch")) {
atbat.id <- frame$atbat_id
}
}
if (j == "pitch" & any(names(tables) == "atbat")) {
frame$num <- atbat.id
}
if (ctr == 1) {
frames <- frame
} else {
frames <- list(frames, frame)
}
ctr <- ctr + 1
}
return(is.list(frames))
if (is.list(frames)) names(frames) <- names(ordered.tables)
return(frames)
}
data <- urlsToDataFrame(urls = urls, tables = list(atbat = ab))
urlsToDataFrame <- function(urls, tables = list(atbat = NULL, pitch = NULL)) {
if (is.null(names(tables))) stop("Please specify at least one XML node of interest.")
#Order tables alphabetically. This is important because the atbat node must be parsed first if you want an atbat ID for the pitch table
orders <- order(names(tables))
ordered.tables <- llply(orders, function(x) { tables[[x]] })
names(ordered.tables) <- names(tables)[orders]
#Start parsing the URLs
docs <- NULL
url.vector <- NULL
for (i in urls) {
cat(i, "\n")
doc <- try_default(xmlParse(i), NULL, quiet = TRUE)
if (!is.null(doc)) {
docs <- c(docs, doc) #Keep non-empty documents
url.vector <- c(url.vector, i) #Keep urls that have data
}
}
#Turn the XML documents into a list of data frames
ctr <- 1
for (j in names(ordered.tables)) {
fields <- unlist(ordered.tables[[ctr]])
frame <- docsToDataFrame(docs = docs, node = j, fields = fields, urls = url.vector)
if (j == "atbat") {
frame <- as.data.frame(frame$final)
if (any(names(tables) == "pitch")) {
atbat.id <- frame$atbat_id
}
}
if (j == "pitch" & any(names(tables) == "atbat")) {
frame$num <- atbat.id
}
if (ctr == 1) {
frames <- frame
} else {
frames <- list(frames, frame)
}
ctr <- ctr + 1
}
return(is.list(frames))
if (is.list(frames)) names(frames) <- names(ordered.tables)
return(frames)
}
data <- urlsToDataFrame(urls = urls, tables = list(atbat = ab))
urlsToDataFrame <- function(urls, tables = list(atbat = NULL, pitch = NULL)) {
if (is.null(names(tables))) stop("Please specify at least one XML node of interest.")
#Order tables alphabetically. This is important because the atbat node must be parsed first if you want an atbat ID for the pitch table
orders <- order(names(tables))
ordered.tables <- llply(orders, function(x) { tables[[x]] })
names(ordered.tables) <- names(tables)[orders]
#Start parsing the URLs
docs <- NULL
url.vector <- NULL
for (i in urls) {
cat(i, "\n")
doc <- try_default(xmlParse(i), NULL, quiet = TRUE)
if (!is.null(doc)) {
docs <- c(docs, doc) #Keep non-empty documents
url.vector <- c(url.vector, i) #Keep urls that have data
}
}
#Turn the XML documents into a list of data frames
ctr <- 1
for (j in names(ordered.tables)) {
fields <- unlist(ordered.tables[[ctr]])
frame <- docsToDataFrame(docs = docs, node = j, fields = fields, urls = url.vector)
if (j == "atbat") {
frame <- frame$final
if (any(names(tables) == "pitch")) {
atbat.id <- frame$atbat_id
}
}
if (j == "pitch" & any(names(tables) == "atbat")) {
frame$num <- atbat.id
}
if (ctr == 1) {
frames <- frame
} else {
frames <- list(frames, frame)
}
ctr <- ctr + 1
}
#return(length(frames))
if (length(names(tables)) > 1) names(frames) <- names(ordered.tables)
return(frames)
}
data <- urlsToDataFrame(urls = urls, tables = list(atbat = ab))
View(data)
data <- urlsToDataFrame(urls = urls, tables = list(pitch = p, atbat = ab))
atbats <- data$atbat
pitches <- data$pitch
View(atbats)
View(pitches)
str(data)
data <- urlsToDataFrame(urls = urls)
docsToDataFrame <- function(docs, node, fields, urls) {
nodes <- llply(docs, function(x) {
getNodeSet(x, paste("//", node, sep=""))
})
attributes <- llply(nodes, function(x) {
if (length(x) > 0) { #Check that each node has at least some info
llply(x, function(y) {
xmlAttrs(y) #Grab all the attributes from each node
})
}
})
if (is.null(fields)) {
fields <- llply(attributes, function(x) {
llply(x, function(y) {
rev(unique(y))[[1]]
})
})
fields <- as.character(rev(unique(fields))[[1]])
}
data <- llply(attributes, function(x) {
llply(x, function(y) {
if (length(y) > 0) {
adjust(y, fields) #Add missing tags and NAs
}
})
})
final <- ldply(data, function(x) {
ldply(x, function(y) { y }) #Coerce all the data from a list of lists to one big dataframe
})
#Create url column to identify where the observation originated.
counts <- llply(nodes, function(x) { length(x) })
url.column <- rep(urls, counts)
final$url <- url.column
if (node == "atbat") {
atbat.id <- createAtbatID(nodes)
return(list(final = final, atbat_id = atbat.id))
} else {
return(final = final)
}
}
urlsToDataFrame <- function(urls, tables = list(atbat = NULL, pitch = NULL)) {
if (is.null(names(tables))) stop("Please specify at least one XML node of interest.")
#Order tables alphabetically. This is important because the atbat node must be parsed first if you want an atbat ID for the pitch table
orders <- order(names(tables))
ordered.tables <- llply(orders, function(x) { tables[[x]] })
names(ordered.tables) <- names(tables)[orders]
#Start parsing the URLs
docs <- NULL
url.vector <- NULL
for (i in urls) {
cat(i, "\n")
doc <- try_default(xmlParse(i), NULL, quiet = TRUE)
if (!is.null(doc)) {
docs <- c(docs, doc) #Keep non-empty documents
url.vector <- c(url.vector, i) #Keep urls that have data
}
}
#Turn the XML documents into a list of data frames
ctr <- 1
for (j in names(ordered.tables)) {
fields <- unlist(ordered.tables[[ctr]])
frame <- docsToDataFrame(docs = docs, node = j, fields = fields, urls = url.vector)
if (j == "atbat") {
frame <- frame$final
if (any(names(tables) == "pitch")) {
atbat.id <- frame$atbat_id
}
}
if (j == "pitch" & any(names(tables) == "atbat")) {
frame$num <- atbat.id
}
if (ctr == 1) {
frames <- frame
} else {
frames <- list(frames, frame)
}
ctr <- ctr + 1
}
if (length(names(tables)) > 1) names(frames) <- names(ordered.tables)
return(frames)
}
data <- urlsToDataFrame(urls = urls)
docs <- NULL
url.vector <- NULL
for (i in urls) {
cat(i, "\n")
doc <- try_default(xmlParse(i), NULL, quiet = TRUE)
if (!is.null(doc)) {
docs <- c(docs, doc) #Keep non-empty documents
url.vector <- c(url.vector, i) #Keep urls that have data
}
}
nodes <- llply(docs, function(x) {
getNodeSet(x, paste("//", node, sep=""))
})
attributes <- llply(nodes, function(x) {
if (length(x) > 0) { #Check that each node has at least some info
llply(x, function(y) {
xmlAttrs(y) #Grab all the attributes from each node
})
}
})
if (is.null(fields)) { #If field names aren't provided, find them.
fields <- llply(attributes, function(x) {
llply(x, function(y) {
names(y)
})
})
fields <- as.character(rev(unique(fields))[[1]])
}
fix(fields)
docsToDataFrame <- function(docs, node, fields, urls) {
nodes <- llply(docs, function(x) {
getNodeSet(x, paste("//", node, sep=""))
})
attributes <- llply(nodes, function(x) {
if (length(x) > 0) { #Check that each node has at least some info
llply(x, function(y) {
xmlAttrs(y) #Grab all the attributes from each node
})
}
})
if (is.null(fields)) { #If field names aren't provided, find them.
fields <- llply(attributes, function(x) {
llply(x, function(y) {
names(y)
})
})
fields <- as.character(rev(unique(fields))[[1]])
}
data <- llply(attributes, function(x) {
llply(x, function(y) {
if (length(y) > 0) {
adjust(y, fields) #Add missing tags and NAs
}
})
})
final <- ldply(data, function(x) {
ldply(x, function(y) { y }) #Coerce all the data from a list of lists to one big dataframe
})
#Create url column to identify where the observation originated.
counts <- llply(nodes, function(x) { length(x) })
url.column <- rep(urls, counts)
final$url <- url.column
if (node == "atbat") {
atbat.id <- createAtbatID(nodes)
return(list(final = final, atbat_id = atbat.id))
} else {
return(final = final)
}
}
urlsToDataFrame <- function(urls, tables = list(atbat = NULL, pitch = NULL)) {
if (is.null(names(tables))) stop("Please specify at least one XML node of interest.")
#Order tables alphabetically. This is important because the atbat node must be parsed first if you want an atbat ID for the pitch table
orders <- order(names(tables))
ordered.tables <- llply(orders, function(x) { tables[[x]] })
names(ordered.tables) <- names(tables)[orders]
#Start parsing the URLs
docs <- NULL
url.vector <- NULL
for (i in urls) {
cat(i, "\n")
doc <- try_default(xmlParse(i), NULL, quiet = TRUE)
if (!is.null(doc)) {
docs <- c(docs, doc) #Keep non-empty documents
url.vector <- c(url.vector, i) #Keep urls that have data
}
}
#Turn the XML documents into a list of data frames
ctr <- 1
for (j in names(ordered.tables)) {
fields <- unlist(ordered.tables[[ctr]])
frame <- docsToDataFrame(docs = docs, node = j, fields = fields, urls = url.vector)
if (j == "atbat") {
frame <- frame$final
if (any(names(tables) == "pitch")) {
atbat.id <- frame$atbat_id
}
}
if (j == "pitch" & any(names(tables) == "atbat")) {
frame$num <- atbat.id
}
if (ctr == 1) {
frames <- frame
} else {
frames <- list(frames, frame)
}
ctr <- ctr + 1
}
if (length(names(tables)) > 1) names(frames) <- names(ordered.tables)
return(frames)
}
data <- urlsToDataFrame(urls = urls)
node <- "atbat"
nodes <- llply(docs, function(x) {
getNodeSet(x, paste("//", node, sep=""))
})
attributes <- llply(nodes, function(x) {
if (length(x) > 0) { #Check that each node has at least some info
llply(x, function(y) {
xmlAttrs(y) #Grab all the attributes from each node
})
}
})
if (is.null(fields)) { #If field names aren't provided, find them.
fields <- llply(attributes, function(x) {
llply(x, function(y) {
names(y)
})
})
fields <- as.character(rev(unique(fields))[[1]])
}
fix(fields)
fields <- llply(attributes, function(x) {
llply(x, function(y) {
names(y)
})
})
what <- as.character(rev(unique(fields))[[1]])
fix(what)
fix(what)
namez <- llply(attributes, function(x) {
llply(x, function(y) {
names(y)
})
})
fields <- unique(unlist(namez))
fix(fields)
urlsToDataFrame <- function(urls, tables = list(atbat = NULL, pitch = NULL)) {
if (is.null(names(tables))) stop("Please specify at least one XML node of interest.")
#Order tables alphabetically. This is important because the atbat node must be parsed first if you want an atbat ID for the pitch table
orders <- order(names(tables))
ordered.tables <- llply(orders, function(x) { tables[[x]] })
names(ordered.tables) <- names(tables)[orders]
#Start parsing the URLs
docs <- NULL
url.vector <- NULL
for (i in urls) {
cat(i, "\n")
doc <- try_default(xmlParse(i), NULL, quiet = TRUE)
if (!is.null(doc)) {
docs <- c(docs, doc) #Keep non-empty documents
url.vector <- c(url.vector, i) #Keep urls that have data
}
}
#Turn the XML documents into a list of data frames
ctr <- 1
for (j in names(ordered.tables)) {
fields <- unlist(ordered.tables[[ctr]])
frame <- docsToDataFrame(docs = docs, node = j, fields = fields, urls = url.vector)
if (j == "atbat") {
frame <- frame$final
if (any(names(tables) == "pitch")) {
atbat.id <- frame$atbat_id
}
}
if (j == "pitch" & any(names(tables) == "atbat")) {
frame$num <- atbat.id
}
if (ctr == 1) {
frames <- frame
} else {
frames <- list(frames, frame)
}
ctr <- ctr + 1
}
if (length(names(tables)) > 1) names(frames) <- names(ordered.tables)
return(frames)
}
#' Turn XML documents into a Data Frames
#'
#' This function adds NAs to missing attributes.
#'
#' @param docs XML documents
#' @param node XML node of interest
#' @param fields "Comlpete" set of field names for the data frame
#' @param urls character vector of URLs used to build data frame
#' @return Returns a data frame.
docsToDataFrame <- function(docs, node, fields, urls) {
nodes <- llply(docs, function(x) {
getNodeSet(x, paste("//", node, sep=""))
})
attributes <- llply(nodes, function(x) {
if (length(x) > 0) { #Check that each node has at least some info
llply(x, function(y) {
xmlAttrs(y) #Grab all the attributes from each node
})
}
})
if (is.null(fields)) { #If field names aren't provided, find them.
namez <- llply(attributes, function(x) {
llply(x, function(y) {
names(y)
})
})
fields <- unique(unlist(namez))
}
data <- llply(attributes, function(x) {
llply(x, function(y) {
if (length(y) > 0) {
adjust(y, fields) #Add missing tags and NAs
}
})
})
final <- ldply(data, function(x) {
ldply(x, function(y) { y }) #Coerce all the data from a list of lists to one big dataframe
})
#Create url column to identify where the observation originated.
counts <- llply(nodes, function(x) { length(x) })
url.column <- rep(urls, counts)
final$url <- url.column
if (node == "atbat") {
atbat.id <- createAtbatID(nodes)
return(list(final = final, atbat_id = atbat.id))
} else {
return(final = final)
}
}
data <- urlsToDataFrame(urls = urls)
str(data)
document(".")
check(".") #Check if changes are legit
document(".")
check(".") #Check if changes are legit
document(".")
check(".") #Check if changes are legit
install_github('pitchFX', 'cpsievert')
install(".") #install the package
library(pitchFX)
?urlsToDataFrame
load("pitchfx.Rdata")
data <- urlsToDataFrame(urls)
