}
}
pitchFX.08 <- getPitchFXTable(year = "2008")
View(pitchFX.08)
UrlsToDataFrame <- function(urls, tags, node) { #Function that greatly reduces time required to build tables.
docs <- NULL
url.vector <- NULL
for (i in urls) {
cat(i, "\n")
doc <- try_default(xmlParse(i), NULL, quiet = TRUE)
if (!is.null(doc)) {
docs <- c(docs, doc) #Keep non-empty documents
url.vector <- c(url.vector, i) #Keep urls that have data
}
}
nodes <- llply(docs, function(x) {
g <- getNodeSet(x, paste("//", node, sep = ""))
})
attributes <- llply(nodes, function(x) {
if (length(x) > 0) { #Check that each node has at least some info
llply(x, function(y) {
xmlAttrs(y) #Grab all the attributes from each node
})
}
})
data.NA <- llply(attributes, function(x) {
llply(x, function(y) {
if (length(y) > 0) {
adjust(y, tags) #Add missing tags and NAs
}
})
})
final <- ldply(data.NA, function(x) {
ldply(x, function(y) { y }) #Coerce all the data from a list of lists to one big dataframe
})
if(node == "atbat" || node == "pitch") { #Add url field to atbats and pitch table (to be used as a key)
counts <- llply(nodes, function(x) { length(x) })
u <- NULL
for (k in 1:length(url.vector)) {
stack <- rep(url.vector[k], counts[k])
u <- c(u, stack)
}
final <- cbind(final, urls = u)
}
if (node == "atbat") { #Add atbat ID field to the atbat table (to be used as a key)
ids <- llply(counts, function(x) { 1:x })
atbat.id <- unlist(ids)
final <- cbind(final, atbat.id)
}
if (node == "pitch") { #Add atbat ID field to the pitch table (to be used as a key)
atbat.nodes <- llply(docs, function(x) {
getNodeSet(x, "//atbat")
})
p.per.ab <- llply(atbat.nodes, function(x) {
llply(x, function(y) {
sum(as.numeric(names(xmlChildren(y)) == "pitch"))
})
})
#ab.per.g <- llply(p.per.ab, function(x) { length(x) })
atbat.records <- NULL
for (k in p.per.ab) {
ctr <- 1
for (j in k) {
atbat.record <- rep(ctr, j)
atbat.records <- c(atbat.records, atbat.record)
ctr <- ctr + 1
}
}
final <- cbind(final, atbat.id = atbat.records)
}
return(final)
}
pitchFX.08 <- getPitchFXTable(year = "2008")
View(pitchFX.08)
getAtbatsTable <- function(year = "2008", database = MLB){
urls <- dbGetQuery(MLB, paste("SELECT url FROM ", year, "_games", sep = ""))
t <- urls[,"url"][1000:1005]
tags <- dbGetQuery(MLB, "SELECT field_name FROM atbat_fields")
all.tags <- tags[, "field_name"]
#all.tags <- getFieldNames(urls = t, node = "atbat")
rawTable <- UrlsToDataFrame(urls = t, tags = all.tags, node = "atbat")
}
atbats.08 <- getAtbatsTable(year = "2008")
View(atbats.08)
install.packages("ProgGUIinR")
visualize <- function(start = Sys.Date(), end = Sys.Date(), pitcher.name, pitch.type, zone = "all", time = 0.01){
suppressMessages(library(gWidgets))
options("guiToolkit"="RGtk2")
atbats <- dbGetQuery(MLB, paste("SELECT * FROM 2011_atbats LEFT JOIN 2011_pitchers ON
(2011_atbats.pitcher_id = 2011_pitchers.pitcher_id
AND 2011_atbats.url = 2011_pitchers.url)
WHERE 2011_pitchers = ", pitcher.name, sep = "")
head(atbats)
}
visualize <- function(start = Sys.Date(), end = Sys.Date(), pitcher.name, pitch.type, zone = "all", time = 0.01){
suppressMessages(library(gWidgets))
options("guiToolkit"="RGtk2")
atbats <- dbGetQuery(MLB, paste("SELECT * FROM 2011_atbats LEFT JOIN 2011_pitchers ON
(2011_atbats.pitcher_id = 2011_pitchers.pitcher_id
AND 2011_atbats.url = 2011_pitchers.url)
WHERE 2011_pitchers = ", pitcher.name, sep = ""))
head(atbats)
}
visualize(start = "2011-01-01", end = Sys.Date, pitcher.name = "Justin Verlander", pitch.type = c("FF", "CU"), zone = "all", time = 0.01)
library(XML) #Load necessary packages for this package
library(plyr)
library(lubridate)
library(stringr)
library(reshape)
library(ggplot2)
library(animation)
library(RMySQL)
#Establish connection with MLB Database
drv <- dbDriver("MySQL")
MLB <- dbConnect(drv, user="root", password="Stats4Life", port=3306, dbname="MLB", host="127.0.0.1")
visualize(start = "2011-01-01", end = Sys.Date, pitcher.name = "Justin Verlander", pitch.type = c("FF", "CU"), zone = "all", time = 0.01)
visualize <- function(start = Sys.Date(), end = Sys.Date(), pitcher.name, pitch.type, zone = "all", time = 0.01, database = MLB){
suppressMessages(library(gWidgets))
options("guiToolkit"="RGtk2")
atbats <- dbGetQuery(database, paste("SELECT * FROM 2011_atbats LEFT JOIN 2011_pitchers ON
(2011_atbats.pitcher_id = 2011_pitchers.pitcher_id
AND 2011_atbats.url = 2011_pitchers.url)
WHERE 2011_pitchers = ", pitcher.name, sep = ""))
head(atbats)
}
visualize(start = "2011-01-01", end = Sys.Date, pitcher.name = "Justin Verlander", pitch.type = c("FF", "CU"), zone = "all", time = 0.01)
ids <- dbGetQuery(MLB, "SELECT pitcher_id, url FROM 2011_pitchers")
ids <- dbGetQuery(MLB, "SELECT pitcher_id, url FROM 2011_atbats")
library(XML) #Load necessary packages for this package
library(plyr)
library(lubridate)
library(stringr)
library(reshape)
library(ggplot2)
library(animation)
library(RMySQL)
#Establish connection with MLB Database
drv <- dbDriver("MySQL")
MLB <- dbConnect(drv, user="root", password="Stats4Life", port=3306, dbname="MLB", host="127.0.0.1")
visualize <- function(first.date = Sys.Date(), last.date = Sys.Date(), pitcher.name, pitch.type, zone = "all", time = 0.01, database = MLB){
#suppressMessages(library(gWidgets))
#options("guiToolkit"="RGtk2")
start <- as.Date(first.date)
end <- as.Date(last.date)
diff <- as.numeric(end - start)
dates <- start + c(0:diff) * days(1) #Create vector of dates from start date to end date
years <- year(dates)
pitchFX <- NULL
for (i in years) {
names <- pitcher.name[1]
for (j in 1:length(pitcher.name)) {
if (!is.na(pitcher.name[j+1])) {
names <- paste(names,  pitcher.name[j+1], sep = paste("' OR ", i, "_pitchers.full_name = '", sep = ""))
}
}
ids <- dbGetQuery(MLB, paste("SELECT DISTINCT id FROM ", i, "_pitchers WHERE ", i, "_pitchers.full_name = '", names, "'", sep = ""))
if (is.null(ids)) stop(paste("Sorry, none of these pitchers played a game in", i, sep = " "))
p.ids <- ids[1, "id"]
for (k in 1:dim(ids)[1]) {
if (!is.na(ids[k+1, "id"])) {
p.ids <- paste(p.ids,  ids[k+1, "id"], sep = paste(" OR ", i, "_atbats.pitcher = ", sep = ""))
}
}
raw.pitches <- dbGetQuery(MLB, paste("SELECT DISTINCT * FROM ", i, "_pitchFX RIGHT JOIN ", i, "_atbats ON (", i, "_pitchFX.atbat_id = ", i, "_atbats.num AND ", i, "_pitchFX.url = ", i, "_atbats.url)  WHERE ", i, "_atbats.pitcher = ", p.ids, sep = ""))
pitches <- cbind(raw.pitches, year = i)
pitchFX <- rbind(pitchFX, pitches)
}
}
data <- visualize(first.date = "2011-01-01", last.date = Sys.Date(), pitcher.name = c("Justin Verlander", "Mariano Rivera"), pitch.type = c("FF", "CU"), zone = "all", time = 0.01)
visualize <- function(first.date = Sys.Date(), last.date = Sys.Date(), pitcher.name, pitch.type, zone = "all", time = 0.01, database = MLB){
#suppressMessages(library(gWidgets))
#options("guiToolkit"="RGtk2")
start <- as.Date(first.date)
end <- as.Date(last.date)
diff <- as.numeric(end - start)
dates <- start + c(0:diff) * days(1) #Create vector of dates from start date to end date
years <- year(dates)
pitchFX <- NULL
for (i in years) {
names <- pitcher.name[1]
for (j in 1:length(pitcher.name)) {
if (!is.na(pitcher.name[j+1])) {
names <- paste(names,  pitcher.name[j+1], sep = paste("' OR ", i, "_pitchers.full_name = '", sep = ""))
}
}
ids <- dbGetQuery(MLB, paste("SELECT DISTINCT id FROM ", i, "_pitchers WHERE ", i, "_pitchers.full_name = '", names, "'", sep = ""))
if (is.null(ids)) stop(paste("Sorry, none of these pitchers played a game in", i, sep = " "))
p.ids <- ids[1, "id"]
for (k in 1:dim(ids)[1]) {
if (!is.na(ids[k+1, "id"])) {
p.ids <- paste(p.ids,  ids[k+1, "id"], sep = paste(" OR ", i, "_atbats.pitcher = ", sep = ""))
}
}
return(p.ids)
#raw.pitches <- dbGetQuery(MLB, paste("SELECT DISTINCT * FROM ", i, "_pitchFX RIGHT JOIN ", i, "_atbats ON (", i, "_pitchFX.atbat_id = ", i, "_atbats.num AND ", i, "_pitchFX.url = ", i, "_atbats.url)  WHERE ", i, "_atbats.pitcher = ", p.ids, sep = ""))
#pitches <- cbind(raw.pitches, year = i)
#pitchFX <- rbind(pitchFX, pitches)
}
}
data <- visualize(first.date = "2011-01-01", last.date = Sys.Date(), pitcher.name = c("Justin Verlander", "Mariano Rivera"), pitch.type = c("FF", "CU"), zone = "all", time = 0.01)
visualize <- function(first.date = Sys.Date(), last.date = Sys.Date(), pitcher.name, pitch.type, zone = "all", time = 0.01, database = MLB){
#suppressMessages(library(gWidgets))
#options("guiToolkit"="RGtk2")
start <- as.Date(first.date)
end <- as.Date(last.date)
diff <- as.numeric(end - start)
dates <- start + c(0:diff) * days(1) #Create vector of dates from start date to end date
years <- year(dates)
pitchFX <- NULL
for (i in years) {
names <- pitcher.name[1]
for (j in 1:length(pitcher.name)) {
if (!is.na(pitcher.name[j+1])) {
names <- paste(names,  pitcher.name[j+1], sep = paste("' OR ", i, "_pitchers.full_name = '", sep = ""))
}
}
ids <- dbGetQuery(MLB, paste("SELECT DISTINCT id FROM ", i, "_pitchers WHERE ", i, "_pitchers.full_name = '", names, "'", sep = ""))
if (is.null(ids)) stop(paste("Sorry, none of these pitchers played a game in", i, sep = " "))
p.ids <- ids[1, "id"]
for (k in 1:dim(ids)[1]) {
if (!is.na(ids[k+1, "id"])) {
p.ids <- paste(p.ids,  ids[k+1, "id"], sep = paste(" OR ", i, "_atbats.pitcher = ", sep = ""))
}
}
raw.pitches <- dbGetQuery(MLB, paste("SELECT DISTINCT x0 FROM ", i, "_pitchFX RIGHT JOIN ", i, "_atbats ON (", i, "_pitchFX.atbat_id = ", i, "_atbats.num AND ", i, "_pitchFX.url = ", i, "_atbats.url)  WHERE ", i, "_atbats.pitcher = ", p.ids, sep = ""))
pitches <- cbind(raw.pitches, year = i)
pitchFX <- rbind(pitchFX, pitches)
}
}
data <- visualize(first.date = "2011-01-01", last.date = Sys.Date(), pitcher.name = c("Justin Verlander", "Mariano Rivera"), pitch.type = c("FF", "CU"), zone = "all", time = 0.01)
library(XML) #Load necessary packages for this package
library(plyr)
library(lubridate)
library(stringr)
library(reshape)
library(ggplot2)
library(animation)
library(RMySQL)
url <- "http://gd2.mlb.com/components/game/mlb/year_2011/month_04/day_15/
gid_2011_04_15_sfnmlb_arimlb_1/inning/inning_all.xml"
doc <- xmlParse(url)
url <- "http://gd2.mlb.com/components/game/mlb/year_2011/month_04/day_15/
gid_2011_04_15_sfnmlb_arimlb_1/inning/inning_all.xml"
doc <- xmlParse(url)
fix(url)
url <- "http://gd2.mlb.com/components/game/mlb/year_2011/month_04/day_15/gid_2011_04_15_sfnmlb_arimlb_1/inning/inning_all.xml"
doc <- xmlParse(url)
atbat <- getNodeSet(doc, "//atbat")
atbat.info <- llply(atbat, function(x) { xmlAttrs(x) })
atbat[1]
library(XML) #Load necessary packages for this package
library(plyr)
library(lubridate)
library(stringr)
library(reshape)
library(ggplot2)
library(animation)
library(RMySQL)
#Establish connection with MLB Database
drv <- dbDriver("MySQL")
MLB <- dbConnect(drv, user="root", password="Stats4Life", port=3306, dbname="MLB", host="127.0.0.1")
#Scraping work horse (for use strictly with package)
parseURLs <- function(urls) { #Function that greatly reduces time required to build tables.
docs <- NULL
url.vector <- NULL
for (i in urls) {
cat(i, "\n")
doc <- try_default(xmlParse(i), NULL, quiet = TRUE)
if (!is.null(doc)) {
docs <- c(docs, doc) #Keep non-empty documents
url.vector <- c(url.vector, i) #Keep urls that have data
}
}
return(docs)
}
scrapePitchFX <- function(start = "2012-01-01", end = Sys.Date()) { #make fields flexible?
first.date <- paste("('", start, "')", sep = "")
if (year(start) < 2005) stop("Not only is pitchFX data not avaliable before 2008, data on each game isn't complete until 2005")
if (year(start) < 2008) stop("Warning: pitchFX data wasn't recorded consistently until 2008. Please consider a later start date.")
last.date <- paste("('", end, "')", sep = "")
if (end > Sys.Date()) stop("Sorry, I can't scrape data on the future!")
urls <- dbGetQuery(MLB, paste("SELECT url FROM all_games WHERE all_games.date >= ", first.date, "AND all_games.date <=", last.date, sep = ""))
t <- urls[,"url"]
docs <- parseURLs(urls = t)
return(docs)
#all.tags <- c("ax", "ay", "az", "break_angle", "break_length", "break_y", "cc", "des",
#              "end_speed", "id", "mt", "nasty", "on_1b", "on_2b", "on_3b", "pfx_x", "pfx_z", "pitch_type",
#              "px", "pz", "spin_dir", "spin_rate", "start_speed", "sv_id", "sz_bot", "sz_top",
#              "tfs", "tfs_zulu", "type", "type_confidence", "vx0", "vy0", "vz0",
#              "x", "x0", "y", "y0", "z0", "zone")
#rawTable <- docsToDataFrame(urls = t, tags = all.tags)
#How do I write table in proper directory? What format should I use?
}
docs <- scrapePitchFX()
fix(doc)
library(devtools)
install_github('pitchFX', 'cpsievert')
?devtools
?ddply
library(plyr)
?plyr
?ddply
head(baseball)
install_github('pitchFX', 'cpsievert')
library(pitchFX)
?pitchFX
?scrapePitchFX
scrapePitchFX()
install_github('gghammock', 'heike')
library(gghammock)
?gghammock
gghammock()
?pitchFX
?gghammock
install_github('pitchFX', 'cpsievert')
install_github('pitchFX', 'cpsievert')
install_github('pitchFX', 'cpsievert')
library(pitchFX)
?pitchFX
?scrapePitchFX
library(devtools)
install_github('pitchFX', 'cpsievert')
install_github('pitchFX', 'cpsievert')
install_github('pitchFX', 'cpsievert')
library(pitchFX)
?pitchFX
?scrapePitchFX
library(devtools)
install_github('pitchFX', 'cpsievert')
library(pitchFX)
?pitchFX
?scrapePitchFX
ptm <- proc.time()
data <- scrapePitchFX(start = "2011-05-01", end = "2011-05-01")
ptm
library(devtools)
install_github('pitchFX', 'cpsievert')
match(c(1,2,3), c(3,2,1))
match(c(1, 2, 3, 4), c(3,2,1))
match(c(1, 2, 3, 4), c(5, 3,2,1))
match(c(1, 2, 3, 4, 7), c(5, 3,2,1))
match(c(1, 2, 3, 5, 7), c(5, 3,2,1))
gsub(NA, NULL, )
test <- match(c(1, 2, 3, 5, 7), c(5, 3,2,1))
test
gsub(NA, NULL, test)
?rm.na
?na.rm
test
test[!is.na(test)]
#' Function for parsing urls and specified nodes into data frames
#'
#' The primary use for this function is to scrape an "atbats" table and the corresponding "pitch"
#' (ie, Pitch F/X) table for the specified set of URLs. In fact, this function is used as the core
#' functionality behind \code{scrapePitchFX}. This function provides added flexibility by allowing
#' one to specify nodes of interest other than "atbat" and "pitch".
#' \bold{Important: You must have "atbat" AND "pitch" nodes if you want to identify who threw a
#' particular pitch. Also, if you specify field names for the table, you should be confident that those
#' are the most complete set of fields.}
#'
#' @param urls set of urls for parsing
#' @param tables list of character vectors containing field names for each table. The list names have to correspond to XML nodes of interest within the XML files.
#' @return Returns a data frames if the length of tables is one. Otherwise, it returns a list of data frames.
#' @export
#' @examples
#' #If it isn't currently baseball season, consider changing the dates below:
#' #Also, this is a small scaled example. Visit my website if you would like to see how to
#' #build a current and complete database.
#' #mini.urls <- getScoreboardURLs(first.date = Sys.Date() - 10, last.date = Sys.Date())
#' #game.urls <- getPitchFxURLs(mini.urls)
#' #data <- urlsToDataFrame(urls = game.urls)
#' #atbats <- data$atbat
#' #pitches <- data$pitch
#'
urlsToDataFrame <- function(urls, tables = list(atbat = NULL, pitch = NULL)) {
if (is.null(names(tables))) stop("Please specify at least one XML node of interest.")
#Order tables alphabetically. This is important because the atbat node must be parsed first if you want an atbat ID for the pitch table
orders <- order(names(tables))
ordered.tables <- llply(orders, function(x) { tables[[x]] })
names(ordered.tables) <- names(tables)[orders]
#Start parsing the URLs
docs <- NULL
url.vector <- NULL
for (i in urls) {
cat(i, "\n")
doc <- try_default(xmlParse(i), NULL, quiet = TRUE)
if (!is.null(doc)) {
docs <- c(docs, doc) #Keep non-empty documents
url.vector <- c(url.vector, i) #Keep urls that have data
}
}
#Turn the XML documents into a list of data frames
ctr <- 1
for (j in names(ordered.tables)) {
fields <- unlist(ordered.tables[[ctr]])
frame <- docsToDataFrame(docs = docs, node = j, fields = fields, urls = url.vector)
if (j == "atbat" & !any(names(tables) == "pitch")) {
frame <- frame$final
}
if (j == "pitch" & any(names(tables) == "atbat")) {
frame$num <- frames$atbat_id
frames$atbat_id <- NULL
}
if (ctr == 1) {
frames <- frame
} else {
frames <- list(as.data.frame(frames), frame)
}
ctr <- ctr + 1
}
if (length(names(tables)) > 1) names(frames) <- names(ordered.tables)
return(frames)
}
#' Turn XML documents into a Data Frames
#'
#' This function adds NAs to missing attributes.
#'
#' @param docs XML documents
#' @param node XML node of interest
#' @param fields "Comlpete" set of field names for the data frame
#' @param urls character vector of URLs used to build data frame
#' @return Returns a data frame.
docsToDataFrame <- function(docs, node, fields, urls) {
nodes <- llply(docs, function(x) {
getNodeSet(x, paste("//", node, sep=""))
})
attributes <- llply(nodes, function(x) {
if (length(x) > 0) { #Check that each node has at least some info
llply(x, function(y) {
xmlAttrs(y) #Grab all the attributes from each node
})
}
})
if (is.null(fields)) { #If field names aren't provided, find them.
namez <- llply(attributes, function(x) {
llply(x, function(y) {
names(y)
})
})
fields <- unique(unlist(namez))
}
data <- llply(attributes, function(x) {
llply(x, function(y) {
if (length(y) > 0) {
adjust(y, fields) #Add missing tags and NAs
}
})
})
final <- ldply(data, function(x) {
ldply(x, function(y) { y }) #Coerce all the data from a list of lists to one big dataframe
})
#Create url column to identify where the observation originated.
counts <- llply(nodes, function(x) { length(x) })
url.column <- rep(urls, counts)
final$url <- url.column
if (node == "atbat") {
atbat.id <- createAtbatID(nodes)
return(list(final = final, atbat_id = atbat.id))
} else {
return(final = final)
}
}
#' "Adjust" attributes to match the entire set
#'
#' This function adds NAs to missing attributes.
#'
#' @param info XML attributes
#' @param tags "complete" set of attribute names.
#Adjust function used inside of UrlsToDataFrame
adjust <- function(info, tags){ #Adds NAs wherever a tag is missing
x <- names(info)
y <- tags
#fields <- intersect(x, y) #available info for that node
z <- match(x, y)
w <- z[!is.na(z)] #get rid of elements in info that doesn't match tags (allows fields to be flexible)
a <- rep(NA, length(tags))
a[z] <- info
names(a) <- tags
return(a)
}
#' Assign each pitch an atbat ID
#'
#' @param nodes XML nodes from a set of URLs. These nodes should be from the "atbat" node.
createAtbatID <- function(nodes) {
p.per.ab <- llply(nodes, function(x) {
llply(x, function(y) {
sum(as.numeric(names(xmlChildren(y)) == "pitch"))
})
})
atbat.records <- llply(p.per.ab, function(x) {
if (length(x) > 0) mapply(rep, 1:length(x), x)
})
return(unlist(atbat.records, use.names=FALSE))
}
data <- urlsToDataFrame(urls, tables = list(atbat = c("away_team_runs", "b", "b_height", "batter", "des", "event")))
library(plyr)
library(XML)
data <- urlsToDataFrame(urls, tables = list(atbat = c("away_team_runs", "b", "b_height", "batter", "des", "event")))
data(all_games)
document(".")
setwd("~/Desktop/github/local/pitchFX")
document(".")
install(".") #install the package
library(pitchFX)
data <- urlsToDataFrame(urls, tables = list(atbat = c("away_team_runs", "b", "b_height", "batter", "des", "event")))
data(all_games)
some.games <- subset(all.games, date >= as.POSIXct("2011-10-01") & date <= as.POSIXct("2011-10-02"))
urls <- some.games[, "url"]
data <- urlsToDataFrame(urls, tables = list(atbat = c("away_team_runs", "b", "b_height", "batter", "des", "event")))
install(".") #install the package
library(pitchFX)
data <- urlsToDataFrame(urls, tables = list(atbat = c("away_team_runs", "b", "b_height", "batter", "des", "event")))
